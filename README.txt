cl-opencl-utils is a library of basic utilities for working with
OpenCL, especially including a Lispified version of OpenCL C.  It is
built on top of the cl-opencl library
(https://www.github.com/ghollisjr/cl-opencl).

The examples/ directory has a few examples showing how to use some of
the included utilities.

make-opencl-reducer and make-opencl-mapper are particularly useful as
they provide basic map and reduce functionality that are
OpenCL-accelerated but relatively convenient to use from a Lisp
perspective.

cl-opencl-utils is GPL3 with the exception of the c-type-name
function, which is possible to use but I'm not sure if it can be
promoted to GPL3 completely.  If so, then cl-opencl-utils is GPL3.  If
not, then just that part isn't.

The Lispified OpenCL C language follows a few rules:

1. If a symbol has not been given special meaning, it will be
   translated into an all-lowercase string, symbols preserved.

2. If the first element of a list does not contain a symbol with a
   special meaning, it is translated into a C-style function call.
   E.g., (f x y) ==> f(x,y).

3. Specialized meanings for symbols are defined with defclc, which
   causes the #'clc function to generate a different C source code
   string result.  E.g., (clc `(zerop x)) ==> ((x) == 0) since zerop
   has a special meaning already defined.

4. Functions in C that have a Lisp equivalent have their Lisp aliases
   defined.  E.g., (expt x y) ==> pow(x,y), but (pow x y) ==> pow(x,y)
   as well.

5. Variables are declared via the var and vararray operators:

  (var :int x 0) ==> int x = 0.
  (var (const :double) f 5d0) ==> const double f = 5.0;
  (vararray :double x (2 3)) ==> double x[2][3].
  (vararray :double y (5) 1 2 3 4 5) ==> double x[5] = {1,2,3,4,5}

6. Blocks are created with progn:

   (progn
    (var :int i 0)
    (var :int j i))
   ==>
   {int i = 0; int j = i;}

7. for and while provide for-loops and while-loops:

   (for (var :int i 0) (< i 10) (incf i)
        (setf sum (+ sum i)))
   ==>
   for(int i = 0; i < 10; ++i) {
     sum = sum + i;
   }

When in doubt, test a form with the #'clc function to see what OpenCL
C code it produces.

Note that symbols are essentially de-packaged from the perspective of
defclc and clc, as they are interned into the cl-opencl-utils package
before processing.  This allows the use of symbols from any package to
denote Lispified OpenCL C code, which is surprisingly inconvenient to
use when symbols are treated as if they belong to a single package and
you don't want to import all of cl-opencl-utils into the package
you're using.  E.g.,

(clc `(cl:+ 2 2)) ==> (2+2)
(clc `(some-package:+ 2 2)) ==> (2+2)

It is possible to define functions and kernels either directly in
source code or using the defclcfun and defclckernel macros.  Once
defined, they can be referenced by other code and will be
automatically declared and included in source code generated by the
following functions and macros:

* program-source-from-forms-fn: Function to create source code from
  top-level forms of Lispified OpenCL C code.

* program-source-from-forms: Macro version of the same where arguments
  aren't evaluated.

* program-source-from-kernels-fn: Creates source code for a program
  from just the kernel symbols supplied.

* program-source-from-kernels: Macro version where the arguments
  aren't evaluated.

For example, a basic hello-world kernel might be produced via:

;; Kernel definition
(defclckernel :void hello
    ((var (global (pointer :uint)) n)
     (var (global (pointer :uint)) buf))
  (var int gid (get-global-id 0))
  (when (< gid (value n))
    (setf (aref buf gid)
          gid)))

;; Make kernel
(let* ((platform (first (cl-get-platform-ids)))
       (device (first (cl-get-device-ids platform
                                         +CL-DEVICE-TYPE-ALL+)))
       (context (cl-create-context platform
                                   (list device)))
       (source
        (program-source-from-kernels hello))
       (program
        (cl-create-program-with-source context source)))
  (cl-build-program-with-log program
                             (list device))
  (cl-create-kernel program "hello"))

I recommend reading the examples at least once to get an idea of how
to use the utilities in a complementary way.  At the moment, I haven't
included macros for the simple reason that the Lispified code is easy
to generate with the backquote syntax, clc, and normal Lisp
functions.
